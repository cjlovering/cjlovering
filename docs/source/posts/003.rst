Transformer Networks
--------------------

.. raw:: html
  :file: assets/header/003.html

Attention is all you need :cite:`vaswani2017attention` introduces the Transformer Network. This network is a shift from recurrent networks; economy inspired its design. It is formulated so that it does not need to use any state or recurrent functions, and is parallelized across all the symbols in an input sequence. However, it is difficult to see how this works across sequences of different length; demonstrating how the Transformer Network fits together is my primary goal for this notebook.

Overview
~~~~~~~~
.. raw:: html

  <hr />

This work focuses on the task of natural language translation (e.g. english to german or vice versa.) This notebook focuses on the unique modules the authors present, and how the system fits together. 

Attention is all you need presents a new neural model call the Transformer Network (TN). It is composed of attention modules, linear mappings, features for increased regularization and an Encoder-Decoder structure. 

External dependencies:

* `Byte-Encoding`_
* Layer Normalization
* Residual Connections
* `Beam Search`_

.. note:: 

  I modify and present implementations from the tensor2tensor_ library and `The Annotated Transformer`_ . For a complete view and implementation of this system, please visit these sources.

Encoder-Decoder Structure
~~~~~~~~~~~~~~~~~~~~~~~~~
.. raw:: html

  <hr />

The transformer uses a `encoder-decoder`_ :cite:`bahdanau2014neural` structure: an input sequence of symbols, :math:`x = { x_1, x_2, \dots, x_n }`, is encoded into a sequence of continuous variables,  :math:`\mathbf{z} = { z_1, z_2, \dots, z_n }`. This is then decoded into a sequence of symbols, :math:`y = { y_1, y_2, \dots, y_n }`. In some cases, :math:`\mathbf{z}` is a single continuous variable. This generation of these symbols occurs one at a time - it is `auto-regressive`_ :cite:`graves`, consuming previously generated symbols as additional input when generating the next. Encoder-decoder structures usually use a recurrent architectures.

.. _`encoder-decoder`: https://arxiv.org/abs/1409.0473
.. _`auto-regressive`: https://arxiv.org/abs/1308.0850

According to Cho et. al :cite:`cho2014learning`, the encoding function :math:`e` can be any non-linear function, but it is often implemented as an RNN.

.. math::
  h_{<t>} = e(h_{<t-1>}, x_t)

.. figure:: /_static/images/003/encoder.svg
  :height: 250px
  :align: center

  Encoder architecture.

The input sentence :math:`x` is encoded into the vector :math:`\mathbf{z}`. Depending on the implemention, we consider the final hidden states as the encoding, or some operation on all the hidden states.

Next, we decode :math:`\mathbf{z}` into the output predictions :math:`y`. Again, this typically uses a recurrent function (RNN).

.. math::
  h_{<t>} = d(h_{<t-1>}, y_{<t-1>}, z)\\
  y_{<t>} = g(h_{<t>}, y_{<t-1>}, z)

.. figure:: /_static/images/003/decoder.svg
   :height: 350px
   :align: center

   Encoder architecture.

This structure has some issues.

1. Its sequential and cannot be easily parallelized.
2. Often :math:`\mathbf{z}` is input into each instance of the decoding function. Because from :math:`\mathbf{z}` there is O(n) distance to each input symbol, it becomes difficult to learn long range dependencies.
3. The path between an output symbol and its corresponding source symbol depends on the length of :math:`x`.

TN's stateless auto-regressive strategy decodes encoded (but not summarized) source words and the current output words ouputting probability distributions for new symbols. This allows the model to be parallelized. 

Scaled Dot-Product Attention
~~~~~~~~~~~~~~~~~~~~~~~~~~~~
.. raw:: html

  <hr />

The authors describe attention as follows:

  An attention function can be described as mapping a query and a set of key-value pairs to an output, where the query, keys, values, and output are all vectors. The output is computed as a weighted sum of the values, where the weight assigned to each value is computed by a compatibility function of the query with the corresponding key.

As noted by the authors, attention maps a query to a combination of given outputs, as determined by the query's corresponding compatibility with the input keys. As the autological "Scaled Dot-Product Attention" method implies, the authors use dot product for their compatibility function. One could use any metric, learned or otherwise, for example cosine distance or a feedforward neural network layer.

For their formulation of attention to work, there are a few requirements for the inputs. There must be mapping between the keys and values, and the compatibility function must be valid (be defined for) the queries and the keys. In the paper, there is 1:1 mapping between the keys and values (by index), and the dot-product compatibility function requires that the queries and the keys have the same dimensionality.

.. figure:: /_static/images/003/attention-explained.svg
  :height: 350px
  :align: center

  Attention inuition.

1. Each key :math:`K_i` maps to a value :math:`V_i`.
2. Each query :math:`Q_j` will operate on all the keys with a compatibility function (dot product). As shown in (b), the closer the vectors are in high-dimensional space, the more compatible. These scores will be transformed into a probability distribution by a softmax.
3. Then, each query will be mapped to a linear combination of the values as determined by the probability distribution (c).

As shown in the example above, the query :math:`q_1` is most similar to :math:`k_1`, thus it is predominantly mapped to the corresponding value :math:`v_1`. Note: these values are examples, not accurate.

The scaled dot product attention is straight forward.

.. math::
  A: Q \times K \times V \to O \\
  Q\in \mathbb{R}^{q \times d}, K \in \mathbb{R}^{n \times d}, V \in \mathbb{R}^{n \times v}, O \in \mathbb{R}^{q \times v} \\
  A = \text{SOFTMAX}(\frac{QK^{\intercal}}{\sqrt{d}}) V

The authors note that the variance of a dot product scales with the size of the input vectors. Increased variance will result in increased magnitude, "pushing the softmax function into regions where it has extremely small gradients." This motivates the scaling of the dot-product based on the dimensionality of the input vectors.

.. note::
  Why is the gradient small?

.. figure:: /_static/images/003/scaled-dot-product.svg
   :height: 350px
   :align: center

   Scaled dot product attention.

Below is an implementation for scaled dot product attention. Each line corresponds to a box in the figure above.

.. code-block:: python3

  def attention(query, key, value, mask=None):
      "Compute 'Scaled Dot Product Attention'"
      # Compatiblity function (dot product) between the query and keys.
      scores = torch.matmul(query, key.transpose(-2, -1))
      # Scale the scores depending on the size of the inputs.
      scores = scores / math.sqrt(query.size(-1))
      # Optional mask. This is used to zero out values that should not be used by this function.
      if mask is not None:    
          scores = scores.masked_fill(mask == 0, -1e9)
      # Compute probability distribution across the final dimension.
      p_attn = F.softmax(scores, dim = -1)
      # Output linear combinations of values, as determined by the distribution.
      return torch.matmul(p_attn, value), p_attn

Self Attention
##############
.. raw:: html

  <hr />

With a single query, self attention will have no effect. This is because the attention mechanism will be a linear combination of the values, and it can only reproduce itself so it serves as an identity function.

.. code-block:: python3

  def SelfAttention(X):
      Q, K, V = X, X, X
      return attention(Q, K, V)
  >>> out, alpha = SelfAttention(torch.FloatTensor([[0.1,0.1,0.8]]))
  >>> print(out)
  tensor([[0.1000, 0.1000, 0.8000]])
  >>> print(alpha)
  tensor([[1.]])

When there are multiple queries, the vectors that are most *compatible* will become more similar because they are mapped to combinations consisting mostly of the already-compatible vectors. The remaining vectors will also be normalized.

.. code-block:: python3

  >>> X = torch.FloatTensor([
      [0,0,1],
      [0,0,2],
      [1,0,0]
  ])
  >>> out, alpha = SelfAttention(X)
  >>> print(alpha)
  tensor([[0.2992, 0.5329, 0.1679],
        [0.2228, 0.7070, 0.0702],
        [0.2645, 0.2645, 0.4711]])

Note that, especially with values greater than 1, a vector can have a greater dot product with other vectors rather than itself. So, similarity is aptly not the correct word to describe this interaction (at least when using a dot product). Thus, the first vector is mapped to a construction consisting mostly of itself and the second vector follows the same trend but more extreme. Lastly, the third vector, less compatible than the others - becomes pseduo-normalized.

Multi Head Attention
~~~~~~~~~~~~~~~~~~~~

The transformer uses "Multi-Head Attention" as its primary module for representational power. It is built up using scaled dot product attention. But, rather than attend raw queries a single time, this method attends *h* linear projections of the input. For each of the *h* heads, the inputs (K,Q,V) are  linearily projected with a learned mapping.

.. math::
  \text{out} = \texttt{Concat}(\text{head}_0, \dots, \text{head}_h) W^O \\
  \text{head}_i = \texttt{Attention}(QW_i^Q, KW_i^K, VW_i^V) \\
  Q \in \mathbb{R}^{q \times m}, K \in \mathbb{R}^{n \times m}, V \in \mathbb{R}^{n \times m} \\
  W_j^Q, W_j^K, W_j^V \in \mathbb{R}^{m \times d} \\
  W^O \in \mathbb{R}^{(h*v)\times m}

.. note:: 
  The compatiblity function and the projections are linear. Does including a non-linearity effect the performance of this method? How well would the transformer perform using a feed forward layer?

.. code-block:: python3

  class MultiHeadedAttention(nn.Module):
      def __init__(self, h, d_model, dropout=0.1):
          "Take in model size and number of heads."
          super(MultiHeadedAttention, self).__init__()
          assert d_model % h == 0
          # We assume d_v always equals d_k
          self.d_k = d_model // h
          self.h = h
          self.linears = clones(nn.Linear(d_model, d_model), 4)
          self.attn = None
          self.dropout = nn.Dropout(p=dropout)
          
      def forward(self, query, key, value, mask=None):
          "Implements Figure 2"
          if mask is not None:
              # Same mask applied to all h heads.
              mask = mask.unsqueeze(1)
          nbatches = query.size(0)
          
          # 1) Do all the linear projections in batch from d_model => h x d_k 
          query, key, value = \
              [l(x).view(nbatches, -1, self.h, self.d_k).transpose(1, 2)
              for l, x in zip(self.linears, (query, key, value))]
          
          # 2) Apply attention on all the projected vectors in batch. 
          x, self.attn = attention(query, key, value, mask=mask, 
                                  dropout=self.dropout)
          
          # 3) "Concat" using a view and apply a final linear. 
          x = x.transpose(1, 2).contiguous() \
              .view(nbatches, -1, self.h * self.d_k)
          return self.linears[-1](x)

Thus, the multi-headed attention is a function from :math:`R^{q \times d}` to :math:`R^{q \times v}`. Furthermore, like the scaled-dot-product attenion, it is able to concurrently operate on all the queries in parallel regardless of the size of the sentence.

Additionally, this module is able to support *h* different heads, and still output a fixed-size vector for each query by concatenation, and then applying a linear mapping to the output.

.. figure:: /_static/images/003/multi-head.svg
   :height: 350px
   :align: center

   Scaled dot product attention.

Input Representation
~~~~~~~~~~~~~~~~~~~~
.. raw:: html

  <hr />

This work used a Byte Pair Encoding scheme. This is a subword tokenization of your vocabulary. This is much more valuable than a UNK symbol. To build this representation, an iterative algorithm links together common segments, starting with character pairs.

Position-wise Feed-Forward Networks
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
.. raw:: html

  <hr />

This two linear transforms with a nonlinear (RELU) operation. The denotation of position-wise remarks on the fact that it is not a convolution, nor does it have any directly spatial functionality.

.. math::
  \text{FFN}(x) = \max(0, xW_1 + b_1)W_2 + b_2

.. code-block:: python3

  class PositionwiseFeedForward(nn.Module):
      "Implements FFN equation."
      def __init__(self, d_model=512, d_ff=2048, dropout=0.1):
          super(PositionwiseFeedForward, self).__init__()
          self.w_1 = nn.Linear(d_model, d_ff)
          self.w_2 = nn.Linear(d_ff, d_model)
          self.dropout = nn.Dropout(dropout)

      def forward(self, x):
          return self.w_2(self.dropout(F.relu(self.w_1(x))))

The remaining features used by the network is residual layers, layer normalization and positional encoding. The structure and features of the model all work to make short paths between inputs and outputs, while also being highly regularized. Layer normalization and residual layers are topics on-to-themselves.

The positional encoding is used to represent the position of the queries in their embeddings. This is important because the attention mechanisms have no notion of order among the queries, and order determines the semantics of a sentence.

The authors use a positional encoding that uses 

.. math::
  \text{PE}_{(pos,2i)} = \sin(pos / 10000^{2i/d_{\text{model}}})\\
  \text{PE}_{(pos,2i+1)} = \cos(pos / 10000^{2i/d_{\text{model}}})

where :math:`pos` is the position and :math:`i` is the dimension.  

As the authors describe:

  That is, each dimension of the positional encoding corresponds to a sinusoid. The wavelengths form a geometric progression from :math:`2\pi` to :math:`10000 \cdot 2\pi`. We chose this function because we hypothesized it would allow the model to easily learn to attend by relative positions, since for any fixed offset :math:`k`, :math:`PE_{pos+k}` can be represented as a linear function of :math:`PE_{pos}`.

.. attention::
  How can this be represented as a linear function?

.. figure:: /_static/images/003/pe.svg
  :height: 350px
  :align: center

  Each dimension corresponds to its location; in the diagram below, each vertical slice of the graph would be added to the input word embeddings.

.. figure:: /_static/images/003/pe-dropout.svg
  :height: 350px
  :align: center

  The authors use dropout to reduce the strength of the signal; the figure demonstrates its effect.

Architecture
~~~~~~~~~~~~
.. raw:: html

  <hr />

Each instance of the transformer will output a probability for the next symbol. As you can see, the encoder and decoder stacks are repeated N times each. In the paper the default was N = 6. The input and ouput of each stack is the of the same dimensionality. In addition to attention modules, they use a few techniques to regularize their network: layer normalization, residual connections, and dropout.


.. figure:: /_static/images/003/architecture.svg
   :height: 650px
   :align: center

Decoding
~~~~~~~~
.. raw:: html

  <hr />

The linear layer takes an input of :math:`\mathbb{R}^{q \times m}` and has a weight shape of :math:`\mathbb{R}^{m \times vocab}`, outputing :math:`\mathbb{R}^{q \times vocab}`. During training, the decoding is set so that all subsequent positions are masked out during attention, so that a symbol could never see "into the future". So, the final linear layer will output a probability distribution for each query (each symbol generated so far) starting with the start symbol. When decoding the next symbol will always be the right-most dimension.

When decoding an output sequence, the network is run repeatedly. A greedy approach looks something like this:

.. code-block:: python3

  def greedy_decode(model, src, src_mask, max_len, start_symbol):
      memory = model.encode(src, src_mask)
      ys = torch.ones(1, 1).fill_(start_symbol).type_as(src.data)
      # generate a word up to the max length. the system could represent stop symbols to stop early.
      for i in range(max_len-1):
          out = model.decode(
              memory, 
              src_mask,
              Variable(ys),
              Variable(subsequent_mask(ys.size(1)).type_as(src.data)))
          # select the final outputs' result.
          prob = model.generator(out[:, -1])
          _, next_word = torch.max(prob, dim = 1)
          next_word = next_word.data[0]
          # concat the most likely word to the result.
          ys = torch.cat([ys, torch.ones(1, 1).type_as(src.data).fill_(next_word)], dim=1)
      return ys

Using `beam search`_ (as the authors did do), a path is selected by maintaining *k* beams - i.e. the best-so-far :math:`k` options.

.. rubric:: Footnotes

* `Byte-Encoding`_
* Layer Normalization
* Residual Connections
* `Beam Search`_
* tensor2tensor_ 
* `The Annotated Transformer`_

.. _`Byte-Encoding`: 001.rst
.. _`Beam Search`: 002.rst
.. _`The Annotated Transformer`: http://nlp.seas.harvard.edu/2018/04/03/attention.html
.. _tensor2tensor: https://github.com/tensorflow/tensor2tensor

.. rubric:: References

.. bibliography:: assets/refs/refs_003.bib
  :style: unsrt
