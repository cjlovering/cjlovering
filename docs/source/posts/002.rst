Beam Search
-----------

Beam search is a method for decoding a sequence, and it is often used translation. In the main, beam search is used at test time, not during training. The algorithm is also described in this paper. For a full implementation see OpenNMT [1]_, otherwise I provide an instructive implementation below.

Given a function f, which takes a prefix of a sequence and outputs a probability distribution of output symbols for the next item in the sequence, beam-search is an approximate algorithm which searches for the path that results in the most probable sequence. The path with the highest probability to start with, may not end up being the most likely sequence. As is common in such methods, log probability is used so that we can sum together the probabilities and avoid floating point errors.

Walkthrough
~~~~~~~~~~~

In this example, we will compute symbols until we reach the maximum length of 4, and maintain 2 beams (or hypotheses). There are three possible output symbols (A, B, C). The log probabilities from the start symbol are -0.39, -0.60, and -0.45. 

.. figure:: /_static/images/002/beam-search-table-01.svg
   :width: 650px
   :align: center

The selected options are those with the highest log probabilities. Now, we will generate the next steps probabilities given these two prefixes (S-A and S-C). Here the search will now continue in different branches. The outputs that are highlighted green indicate that they are the paths with the current highest log probabilities.

.. figure:: /_static/images/002/beam-search-table-02.svg
   :width: 650px
   :align: center

Note that in this time step that one branch will fade completely, as the other branch contains all the top options.

.. figure:: /_static/images/002/beam-search-table-03.svg
   :width: 650px
   :align: center

Finally, beam search will select the path with total lowest log probability.

.. figure:: /_static/images/002/beam-search-table-04.svg
   :width: 650px
   :align: center

Further, it is possible that if we searched all the paths, extending out from options we pruned early on by keeping only the top beams, we may have recieved a different result. If one used depth-first search, each path would be evaluated, but at exponential cost. For example, with a vocabulary of 3 possible output symbols, and a maximum length of 4 symbols, finding the most likely path would cost 81 operations, compared to the 8 we demonstrate above. Beam search does not maintain all possibilities. It keeps the current best-so-far h possibilties, only requiring a linear number of operations.

Below is a demonstration of how the algorithm searches through the graph of paths, pruning all but the number of parameterized number of beams at each time step.

.. raw:: html
  :file: assets/viz/beam-search-graph.html

.. literalinclude:: assets/code/002/beam_search.py

.. [1] https://github.com/OpenNMT/OpenNMT-py/blob/master/onmt/translate/beam.py
